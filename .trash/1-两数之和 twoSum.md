# 题目
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。 

实例1
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

实例2
```
**输入：**nums = [3,2,4], target = 6
**输出：**[1,2]
```

示例3

```
**输入：**nums = [3,3], target = 6
**输出：**[0,1]
```

# 求解
## 1
Language : #Java
Degree of difficulty : #easy

```

```

# 思路和笔记
- 暴力求解
	- 时间复杂度：O(n2)
	- 空间复杂度：O(1)（只用到常数个临时变量）
- 查找表法

- 在遍历的同时，记录一些信息，以省去一层循环，以时间换空间
	- 需要记录已经遍历过的数值和它所对应的下标，可以借助查找表实现
	- 常用的两个实现
		- 哈希表（无序）
		- 平衡二叉搜索树（有序）

- 哈希法，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。
	- 时间复杂度：O(n)
	- 空间复杂度：O(n)：哈希表最多需要存 n-1 个键值对
	
- 时间换空间（程序运行的时间是无法回收的，而空间是可以回收的，因此大多数情况下应该优先考虑降低时间复杂度。）

- 为什么会想到用哈希表
	- 需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合

- 哈希表为什么用map
	- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
	- set是一个集合，里面放的元素只能是一个key，这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。
	- 
- 本题map是用来存什么的
	- 存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下表，这样才能找到与当前元素相匹配的（也就是相加等于target）
	- 
- map中的key和value用来存什么的
	- key：数据元素，value：数组元素对应的下表
